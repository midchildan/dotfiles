#!/usr/bin/env bash

ENABLE_DRYRUN=

main() {
  for n in "$@"; do
    case "$n" in
      -n|--dry-run) ENABLE_DRYRUN=1; shift ;;
      -h|--help) usage ;;
      *) break ;;
    esac
  done

  local remote_name="$1"
  local remote_url="$2"

  local repo_root="$(git config --get-all ghq.root | head -n1)"
  local repo_root="${repo_root/#\~/$HOME}"
  local local_path="$(git rev-parse --show-toplevel)"

  if [[ "$remote_url" =~ :$ ]]; then
    local remote_host="${remote_url%:}"
    local remote_path="${local_path#$repo_root/}"
  elif [[ "$remote_url" =~ : ]]; then
    local remote_host="${remote_url%%:*}"
    local remote_prefix="${remote_url#*:}"
    local remote_path="${local_path/#$repo_root/$remote_prefix}"
  else
    local remote_host="$remote_url"
    local remote_path="${local_path#$repo_root/}"
  fi

  echo "[WARNING] Don't use this for production, as you'll risk exposing your .git directory"

  run ssh "$remote_host" git init "$remote_path"
  run ssh "$remote_host" git -C "$remote_path" config receive.denyCurrentBranch updateInstead
  run git remote add "$remote_name" "$remote_host:$remote_path"
  run git config "remote.$remote_name.push" "+HEAD:master"
}

usage() {
cat <<EOF
usage: $0 [options] [name] [host[:path]]

options:
  -h, --help		Show usage and exit
  -n, --dry-run		Don't acutally make any changes
EOF

exit
}

run() {
  echo "$(tput bold)>$(tput sgr0) $*"
  if [[ -z "$ENABLE_DRYRUN" ]]; then
    "$@"
  fi
}

main "$@"
